#example script#fit a baseline-category logit model for next year's state conditional on this year's state#saves to example.RData#does MCMC diagnostics#produces the diagnostic plots in the supporting information to the paper#NOTES#1. The MCMC in this example isn't run for long enough to converge, only to demonstrate how it's used.#2. We're simulating a pretty small sample, so we may sometimes get error messages connected with the smoothing in the diagnostic plots. Suggest simply running the simulation again in these cases.rm(list=ls())library(nnet) #only needed for the quick check using MLlibrary(rjags)library(mgcv)source("simulate.densitystructure.R")source("chainfuncsmulti.R")source("construct.P.R")source("transition.count.R")source("transition.count.R")source("Psummary.R")source("plotP.R")#simulate some dataalpha <- matrix(c(0,0.1,0.2,0.3,0,0.1,0.5,1.5,0,0.5,1.0,2.0,0,0.1,0.2, 0.3),nrow=4,ncol=4)beta <- array(0.1*1:32,c(4,4,2))beta[1,,] <- 0 #identifiability constraintnsim <- 1e2 #number of simulated observations: with only 100, we may not do that well...ncat <- 4 #number of simulated categoriespinit <- c(0.1,0.2,0.3,0.4) #initial state probabilities for simulated dataspdata <- simulate.densitystructure(nsim,ncat,pinit,alpha,beta)#test numbers: nowhere near long enough in realitynadapt <-100 #length of adaptation periodnburn <- 100 #length of burnin periodniter <- 100 #number of iterations after burninnthin <- 1 #frequency of sampling from chainncat <- 4 #number of abundance categoriesnchain <- 4 #number of MCMC chainsinitsd <- 25 #standard deviation for initial conditions of alpha and beta in MCMCprec <- 0.00001 #precision for prior distributions on alpha and betaplot.diagnostics <- FALSE #do we make the MCMC diagnostic plots? There are a lot of them, and they aren't here arranged in a particularly convenient wayrunMCMC <- TRUE #run the MCMC?fitML <- FALSE #also do ML estimation as a check?m <- transition.count(spdata,ncat) #summary table of transition countsprint("observed transition counts")print(m)sub1 <- spdata[spdata$yt==1,]sub2 <- spdata[spdata$yt==2,]sub3 <- spdata[spdata$yt==3,]sub4 <- spdata[spdata$yt==4,]if(fitML){	#quick check using maximum likelihood	mod1<-multinom(ytplus~scalefetch+scalesst,data=sub1)	print(summary(mod1))	mod2<-multinom(ytplus~scalefetch+scalesst,data=sub2)	print(summary(mod2))	mod3<-multinom(ytplus~scalefetch+scalesst,data=sub3)	print(summary(mod3))	mod4<-multinom(ytplus~scalefetch+scalesst,data=sub4)	print(summary(mod4))}#compile matrices of explanatory variables (centred and scaled sst and wave fetch)sub1x <- as.matrix(cbind(sub1$scalesst,sub1$scalefetch))sub2x <- as.matrix(cbind(sub2$scalesst,sub2$scalefetch))sub3x <- as.matrix(cbind(sub3$scalesst,sub3$scalefetch))sub4x <- as.matrix(cbind(sub4$scalesst,sub4$scalefetch))if(runMCMC){	#baseline-category logit models, conditional on each current state	jags1.out <- jagsout(sub1x,sub1$ytplus,ncat,nchain,nadapt,nburn,niter,thin,initsd,prec)	jags2.out <- jagsout(sub2x,sub2$ytplus,ncat,nchain,nadapt,nburn,niter,thin,initsd,prec)	jags3.out <- jagsout(sub3x,sub3$ytplus,ncat,nchain,nadapt,nburn,niter,thin,initsd,prec)	jags4.out <- jagsout(sub4x,sub4$ytplus,ncat,nchain,nadapt,nburn,niter,thin,initsd,prec)	jags1.alpha <- as.mcmc.list(jags1.out$alpha)	jags2.alpha <- as.mcmc.list(jags2.out$alpha)	jags3.alpha <- as.mcmc.list(jags3.out$alpha)	jags4.alpha <- as.mcmc.list(jags4.out$alpha)	jags1.beta <- as.mcmc.list(jags1.out$beta)	jags2.beta <- as.mcmc.list(jags2.out$beta)	jags3.beta <- as.mcmc.list(jags3.out$beta)	jags4.beta <- as.mcmc.list(jags4.out$beta)	#mcmc diagnostics	print("jags1.alpha")	print(gelman.diag(jags1.alpha[,-1,])) #skip alpha_1, fixed at 0	print(effectiveSize(jags1.alpha))	print("jags1.beta")	print(gelman.diag(jags1.beta[,c(-1,-5),])) #first and 5th elements fixed at 0	print(effectiveSize(jags1.beta))	print("jags2.alpha")	print(gelman.diag(jags2.alpha[,-1,])) #skip alpha_1, fixed at 0	print(effectiveSize(jags2.alpha))	print("jags2.beta")	print(gelman.diag(jags2.beta[,c(-1,-5),])) #first and 5th elements fixed at 0	print(effectiveSize(jags2.beta))	print("jags3.alpha")	print(gelman.diag(jags3.alpha[,-1,])) #skip alpha_1, fixed at 0	print(effectiveSize(jags3.alpha))	print("jags3.beta")	print(gelman.diag(jags3.beta[,c(-1,-5),])) #first and 5th elements fixed at 0	print(effectiveSize(jags3.beta))	print("jags4.alpha")	print(gelman.diag(jags4.alpha[,-1,])) #skip alpha_1, fixed at 0	print(effectiveSize(jags4.alpha))	print("jags4.beta")	print(gelman.diag(jags4.beta[,c(-1,-5),])) #first and 5th elements fixed at 0	print(effectiveSize(jags4.beta))	if(plot.diagnostics){	  plot(as.mcmc.list(jags1.alpha))	  par(mfrow=c(4,2))  	  traceplot(jags1.beta)  	  densplot(jags1.beta)  	  plot(as.mcmc.list(jags2.alpha))  	  par(mfrow=c(4,2))  	  traceplot(jags2.beta)  	  densplot(jags2.beta)  	  plot(as.mcmc.list(jags3.alpha))  	  par(mfrow=c(4,2))  	  traceplot(jags3.beta)  	  densplot(jags3.beta)  	  plot(as.mcmc.list(jags4.alpha))  	  par(mfrow=c(4,2))  	  traceplot(jags4.beta)  	  densplot(jags4.beta)	  }	  #compile MCMC output	  alljags <- list(jags1.out,jags2.out,jags3.out,jags4.out)	  #save the MCMC output	  save(spdata,ncat,alljags,file="example.RData")}#model (rather than MCMC) diagnostics#make all the transition probability matrices: may take a long time!	x<-cbind(spdata$scalesst,spdata$scalefetch)P <- construct.p(alljags,x)print("Observed marginal counts")print(tc <- transition.count(spdata,ncat)) #observed marginal countsiters <- 1:100 #USING ONLY FIRST 100 ITERATIONSsprintf("Predicted marginal counts, using first %d iterations",max(iters))print(pc <- Psummary(P,iters,spdata)) #predicted marginal counts, averaged over iterationsplotP(ncat,P,iters,spdata,1) #plot predicted transition probs from source cat 1. Note: bug in this plotting routine: sometimes the marginal dot plots don't appear for the top left panel. If so, just plot it again and they appear next time. Don't know why...Also note that with the tiny samples we're simulating here, you might sometimes get error messages from mgcv about smoothing problems.plotP(ncat,P,iters,spdata,2) #source cat 2plotP(ncat,P,iters,spdata,3) #source cat 3plotP(ncat,P,iters,spdata,4) #source cat 4#make the contour plots of predicted probability of presence and normalized entropy from the paper (takes a while)source("example.envelope.R")